# Содержание
* Файлы
  * Создание
  * Удаление  
* Папки
  * Удаление
* [Использование дискового пространства](#использование-дискового-пространства)
# Файлы
## Создание
```shell
$ mkdir <foldername>
$ mkdir -p <a/b/c/d>   # создание цепочки вложенных папок
```
## Удаление файлов
### Удаление файлов и папок в директории
```shell
$ rm -rf *
```
r - рекурсивное удаление папок  
f - удаление без подтверждения
# Папки
## Удаление
```shell
$ rmdir <folder_name> # удаляет только пустую папку
$ rm -r <folder_name> # удаляет папку с содержимым
```
# Использование дискового пространства
```shell
# 5 самых используемых папок/файлов в текущей директории, включая подкаталоги
$ sudo du -Sh | sort -rh | head -5
```
```shell
# команда отображает используемое дисковое пространство папкой / и всех ее подпапок первого уровня в порядке убывания размера
time sudo du -h --max-depth=1 / | sort -rh
```

# Знаете ли вы, что в Linux rm не всегда освобождает место сразу?

Бывает такое, что файла нет, а место на диске все равно занято: чистим лог через rm или обновляем исполняемый файл через удаление и создание нового, а старая версия продолжает жить и работать. Дело в том, что в Unix-системах rm на самом деле не всегда удаляет данные с диска.

Вот простой эксперимент:

# Создаем тестовую папку и переходим в неё
mkdir ~/unlink_demo && cd ~/unlink_demo

# Создаем большой файл (1024MB)
dd if=/dev/zero of=bigfile bs=1M count=1024

# Открываем файл на запись (держим дескриптор)
exec 3>>bigfile

# Проверяем, что процессы держат файл
lsof | grep bigfile

# Удаляем файл из файловой системы
rm bigfile

# Файл исчез из директории
ls -la bigfile  # No such file or directory

# НО процесс все еще держит удаленный файл
lsof | grep bigfile

# Закрываем дескриптор - теперь файл окончательно исчезнет
exec 3>&-

# Проверяем - теперь никто файл не держит
lsof | grep bigfile  # Пусто

# Чистим за собой
cd ~ && rm -rf unlink_demo

Процесс продолжает держать удаленный файл через открытый дескриптор. lsof показывает, что файл физически существует на диске, хотя его имя исчезло из файловой системы. Это объясняет, почему удаление больших логов не всегда освобождает место на диске – если какой-то процесс (веб-сервер, база данных, приложение) держит файл открытым, данные остаются в системе до закрытия всех дескрипторов:

# Представим, что лог-файл разросся до 10GB
ls -lh /var/log/app.log  # 10G

# "Очищаем" его удалением
rm /var/log/app.log

# Проверяем место на диске
df -h  # А место не освободилось!

# Приложение продолжит писать в "удаленный" файл
ps aux | grep app  # Процесс работает
lsof -p $(pgrep app) | grep deleted  # Увидим deleted файлы

В реальной жизни это частая проблема с ротацией логов: администратор удаляет огромный access.log, но Apache/Nginx продолжает писать в "несуществующий" файл, и место на диске не освобождается. Правильно – либо перезапустить сервис, либо использовать truncate вместо rm, либо послать сигнал процессу для переоткрытия логов:

# Усекаем файл до нуля, не удаляя его
> /var/log/app.log
# или
echo "" > /var/log/app.log
# или  
truncate -s 0 /var/log/app.log

Можно даже восстановить "удаленный" файл через дескриптор процесса:

# Файл удален, но процесс его держит
echo "Important data" > important.txt
cat important.txt &  # Читаем в фоне
CAT_PID=$!
rm important.txt

# Находим дескриптор и восстанавливаем
ls -la /proc/$CAT_PID/fd/
cp /proc/$CAT_PID/fd/3 important_recovered.txt

kill $CAT_PID

Эта особенность используется для обновления исполняемых файлов без остановки сервисов:

# Заменяем исполняемый файл
cp new_binary /usr/bin/service
# Старые процессы продолжают работать со старой версией
# Новые процессы будут использовать новую версию

# Плавно перезапускаем через systemd
systemctl reload service

А еще это объясняет, почему Docker контейнеры могут продолжать занимать место после удаления файлов – процессы внутри контейнера держат дескрипторы на удаленные файлы.

Проверить "удаленные, но открытые" файлы:

# Посмотреть все открытые файлы процесса
lsof -p PID_ПРОЦЕССА

# Найдет все удаленные файлы
lsof | grep deleted

В Unix удаление файла (unlink) убирает только имя из директории, но не данные с диска. Файл физически удалится только когда на него не останется ни одной ссылки – ни в файловой системе, ни в открытых дескрипторах процессов. Поэтому всегда проверяйте lsof, если место на диске не освобождается после удаления файлов.

Код на салфетке (https://t.me/press_any_button) x Кусочки кода (https://t.me/codebites)
